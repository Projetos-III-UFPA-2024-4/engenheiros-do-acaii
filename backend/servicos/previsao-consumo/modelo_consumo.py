# -*- coding: utf-8 -*-
"""Modelo previs√£o de consumo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LsscA81th2iNfzKPoEEQ9FgseGxcRJxg

## Importando bibliotecas necess√°rias
"""

# Instalar Prophet
#pip install prophet

# Importar bibliotecas
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.model_selection import train_test_split
import pymysql
from dotenv import load_dotenv

# Carregar vari√°veis de ambiente do arquivo .env
load_dotenv()

# üîπ Configura√ß√£o do Banco de Dados MySQL
DB_USERNAME = os.getenv("DB_USERNAME")
DB_PASSWORD = os.getenv("DB_PASSWORD")
DB_NAME = os.getenv("DB_NAME")
DB_HOST = os.getenv("DB_HOST")

# Fun√ß√£o para estabelecer conex√£o com o banco de dados MySQL
def get_db_connection():
    """Estabelece e retorna uma conex√£o com o banco de dados MySQL."""
    try:
        conn = pymysql.connect(
            host=DB_HOST,
            user=DB_USERNAME,
            password=DB_PASSWORD,
            database=DB_NAME,
            cursorclass=pymysql.cursors.DictCursor  # Retorna os resultados como dicion√°rio
        )
        print(f"‚úÖ Conectado ao banco de dados: {DB_NAME}")
        return conn
    except pymysql.MySQLError as e:
        print(f"‚ùå Erro ao conectar ao banco de dados: {e}")
        return None

# Fun√ß√£o para puxar dados do banco e carregar em um DataFrame
def puxar_dados_do_banco():
    """Puxa os dados da tabela e carrega no DataFrame."""
    conn = get_db_connection()
    if conn:
        try:
            query = "SELECT * FROM medicao_consumo;"  # Consulta para pegar todos os dados da tabela
            df = pd.read_sql(query, conn)  # Carregar os dados diretamente para um DataFrame
            print("‚úÖ Dados carregados com sucesso do banco!")
            return df
        except Exception as e:
            print(f"‚ùå Erro ao executar consulta: {e}")
        finally:
            conn.close()
            print("üîå Conex√£o fechada.")
    else:
        return None

# üîπ Carregar os dados do banco
data = puxar_dados_do_banco()

# Verificar os primeiros registros
if data is not None:
    print(data.head())

# from google.colab import files

# # Fazer upload do arquivo manualmente
# uploaded = files.upload()

# # Carregar o dataset (ajuste o nome do arquivo conforme necess√°rio)
# data = pd.read_csv("Dataset_Simulado_de_Consumo.csv", sep=',')

# # Exibir as primeiras linhas
# data.head()

"""## Visualizando dados"""

data.head()

"""## Implementa√ß√£o do modelo Prophet

prepara√ß√£o dos dados
"""

data["consumoTotal"] = data["consumoTotal"].astype(str)
data["consumoTotal"] = data["consumoTotal"].str.replace(',', '.', regex=False)
data["consumoTotal"] = data["consumoTotal"].astype(float)
data.info()

# Converter a coluna 'timestamp' para formato de data
data['timestamp'] = pd.to_datetime(data['timestamp'])

# Selecionar apenas as colunas necess√°rias para o Prophet
df = data[['timestamp', 'consumoTotal']].rename(columns={'timestamp': 'ds', 'consumoTotal': 'y'})

# Garantir que a s√©rie temporal tenha uma frequ√™ncia uniforme
df = df.set_index("ds").asfreq("10min").reset_index()


# Exibir os primeiros registros formatados
df.head()

# Dividir os dados aleatoriamente em 80% treino e 20% teste
train, test = train_test_split(df, test_size=0.2)

# Ordenar os dados pelo timestamp dentro de cada conjunto para manter a coer√™ncia temporal
train = train.sort_values(by="ds")
test = test.sort_values(by="ds")

# Exibir os tamanhos dos conjuntos
print(f"Tamanho do treino: {len(train)}, Tamanho do teste: {len(test)})")

# Criar e treinar o modelo Prophet
modelo = Prophet()
# modelo.add_seasonality(name="diario", period=24, fourier_order=10)  # Padr√£o di√°rio
# modelo.add_seasonality(name="semanal", period=24*7, fourier_order=5)  # Padr√£o semanal
modelo.fit(train)

# Criar um dataframe com datas futuras para o per√≠odo de teste
future = modelo.make_future_dataframe(periods=len(test), freq='15T')

# Fazer a previs√£o
forecast = modelo.predict(future)

# Selecionar apenas as previs√µes correspondentes ao per√≠odo de teste
forecast_test = forecast.iloc[-len(test):]

# Exibir as primeiras previs√µes
forecast_test[['ds', 'yhat']].head()

test['y'] = test['y'].fillna(0)
nan_count = test['y'].isna().sum()
print(f"NaN na coluna 'y': {nan_count}")

# Calcular Erro Absoluto M√©dio (MAE)
mae = mean_absolute_error(test['y'], forecast_test['yhat'])

# Calcular Erro Quadr√°tico M√©dio (MSE)
mse = mean_squared_error(test['y'], forecast_test['yhat'])

# Calcular Raiz do Erro Quadr√°tico M√©dio (RMSE)
rmse = np.sqrt(mse)

print(f"MAE: {mae:.2f}")
print(f"MSE: {mse:.2f}")
print(f"RMSE: {rmse:.2f}")

plt.figure(figsize=(12, 6))

# Plotar valores reais do conjunto de teste
plt.plot(test['ds'], test['y'], label='Valores Reais', color='blue')

# Plotar previs√µes do modelo
plt.plot(forecast_test['ds'], forecast_test['yhat'], label='Previs√£o Prophet', color='red')

plt.title("Compara√ß√£o: Previs√µes vs. Valores Reais")
plt.xlabel("Data")
plt.ylabel("Consumo Total de Energia")
plt.legend()
plt.show()

# Plotar os componentes da previs√£o (tend√™ncia e sazonalidade)
modelo.plot_components(forecast)
plt.show()

# Criar um DataFrame comparativo entre valores reais e previstos
df_comparacao = pd.DataFrame({
    "timestamp": test["ds"].values,
    "valor_real": test["y"].values,
    "previsao_prophet": forecast_test["yhat"].values,
    "erro_absoluto": np.abs(test["y"].values - forecast_test["yhat"].values)
})

# Exibir as primeiras linhas do DataFrame
df_comparacao.head()

"""## Implementa√ß√£o do modelo ARIMA"""

