# -*- coding: utf-8 -*-
"""Modelo previs√£o de consumo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LsscA81th2iNfzKPoEEQ9FgseGxcRJxg

## Importando bibliotecas necess√°rias
"""

# Instalar Prophet
#pip install prophet

# Importar bibliotecas
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.model_selection import train_test_split
import pymysql
from dotenv import load_dotenv

# Carregar vari√°veis de ambiente do arquivo .env
load_dotenv()

# üîπ Configura√ß√£o do Banco de Dados MySQL
DB_USERNAME = os.getenv("DB_USERNAME")
DB_PASSWORD = os.getenv("DB_PASSWORD")
DB_NAME = os.getenv("DB_NAME")
DB_HOST = os.getenv("DB_HOST")

# Fun√ß√£o para estabelecer conex√£o com o banco de dados MySQL
def get_db_connection():
    """Estabelece e retorna uma conex√£o com o banco de dados MySQL."""
    try:
        conn = pymysql.connect(
            host=DB_HOST,
            user=DB_USERNAME,
            password=DB_PASSWORD,
            database=DB_NAME,
            cursorclass=pymysql.cursors.DictCursor  # Retorna os resultados como dicion√°rio
        )
        print(f"‚úÖ Conectado ao banco de dados: {DB_NAME}")
        return conn
    except pymysql.MySQLError as e:
        print(f"‚ùå Erro ao conectar ao banco de dados: {e}")
        return None

# # Fun√ß√£o para puxar dados do banco e carregar em um DataFrame
# def puxar_dados_do_banco():
#     """Puxa os dados da tabela e carrega no DataFrame."""
#     conn = get_db_connection()
#     if conn:
#         try:
#             query = "SELECT timestamp FROM medicao_consumo;;"  # Consulta para pegar todos os dados da tabela
#             df = pd.read_sql(query, conn)  # Carregar os dados diretamente para um DataFrame
#             print("‚úÖ Dados carregados com sucesso do banco!")
#             return df
#         except Exception as e:
#             print(f"‚ùå Erro ao executar consulta: {e}")
#         finally:
#             conn.close()
#             print("üîå Conex√£o fechada.")
#     else:
#         return None

# # üîπ Carregar os dados do banco
# data = puxar_dados_do_banco()

def visualizar_dados_do_banco():
    # Estabelece a conex√£o com o banco de dados
    conn = get_db_connection()
    
    if not conn:
        print("‚ùå N√£o foi poss√≠vel conectar ao banco de dados.")
        return None

    try:
        with conn.cursor() as cursor:
            # Consulta SQL para pegar todas as medi√ß√µes
            query = """
                SELECT id, timestamp, consumoTotal
                FROM medicao_consumo;
            """
            cursor.execute(query)
            
            # Pega todos os resultados
            todas_as_medicoes = cursor.fetchall()

            # Verifica se h√° resultados
            if todas_as_medicoes:
                # Converte para um DataFrame do pandas para uso em modelos
                df = pd.DataFrame(todas_as_medicoes)
                return df  # Retorna o DataFrame com os dados
            else:
                print("Nenhuma medi√ß√£o encontrada.")
                return None
        
    except pymysql.MySQLError as e:
        print(f"‚ùå Erro ao realizar a consulta: {e}")
        return None
    
    finally:
        conn.close()

# Chama a fun√ß√£o e captura os dados
data = visualizar_dados_do_banco()

# Verificar os primeiros registros
# if data is not None:
#     print("aqui")
#     print(data["consumoTotal"].head())

# from google.colab import files

# # Fazer upload do arquivo manualmente
# uploaded = files.upload()

# # Carregar o dataset (ajuste o nome do arquivo conforme necess√°rio)
# data = pd.read_csv("Dataset_Simulado_de_Consumo.csv", sep=',')

# # Exibir as primeiras linhas
# data.head()

"""## Visualizando dados"""

data.head()

"""## Implementa√ß√£o do modelo Prophet

prepara√ß√£o dos dados
"""
data["consumoTotal"] = pd.to_numeric(data["consumoTotal"], errors='coerce')
print(data[data["consumoTotal"].isna()])
data["consumoTotal"] = data["consumoTotal"].astype(str)
data["consumoTotal"] = data["consumoTotal"].str.replace(',', '.', regex=False)
data["consumoTotal"] = data["consumoTotal"].astype(float)
data.info()

# Converter a coluna 'timestamp' para formato de data
data['timestamp'] = pd.to_datetime(data['timestamp'])

# Selecionar apenas as colunas necess√°rias para o Prophet
df = data[['timestamp', 'consumoTotal']].rename(columns={'timestamp': 'ds', 'consumoTotal': 'y'})

# Garantir que a s√©rie temporal tenha uma frequ√™ncia uniforme
df = df.set_index("ds").asfreq("10min").reset_index()


# Exibir os primeiros registros formatados
df.head()

# Dividir os dados aleatoriamente em 80% treino e 20% teste
train, test = train_test_split(df, test_size=0.2)

# Ordenar os dados pelo timestamp dentro de cada conjunto para manter a coer√™ncia temporal
train = train.sort_values(by="ds")
test = test.sort_values(by="ds")

# Exibir os tamanhos dos conjuntos
print(f"Tamanho do treino: {len(train)}, Tamanho do teste: {len(test)})")

# Criar e treinar o modelo Prophet
modelo = Prophet()
# modelo.add_seasonality(name="diario", period=24, fourier_order=10)  # Padr√£o di√°rio
# modelo.add_seasonality(name="semanal", period=24*7, fourier_order=5)  # Padr√£o semanal
modelo.fit(train)

# Criar um dataframe com datas futuras para o per√≠odo de teste
future = modelo.make_future_dataframe(periods=len(test), freq='10min')

# Fazer a previs√£o
forecast = modelo.predict(future)

# Selecionar apenas as previs√µes correspondentes ao per√≠odo de teste
forecast_test = forecast.iloc[-len(test):]

# Exibir as primeiras previs√µes
forecast_test[['ds', 'yhat']].head()

test['y'] = test['y'].fillna(0)
nan_count = test['y'].isna().sum()
print(f"NaN na coluna 'y': {nan_count}")

# Calcular Erro Absoluto M√©dio (MAE)
mae = mean_absolute_error(test['y'], forecast_test['yhat'])

# Calcular Erro Quadr√°tico M√©dio (MSE)
mse = mean_squared_error(test['y'], forecast_test['yhat'])

# Calcular Raiz do Erro Quadr√°tico M√©dio (RMSE)
rmse = np.sqrt(mse)

print(f"MAE: {mae:.2f}")
print(f"MSE: {mse:.2f}")
print(f"RMSE: {rmse:.2f}")

plt.figure(figsize=(12, 6))

# Plotar valores reais do conjunto de teste
plt.plot(test['ds'], test['y'], label='Valores Reais', color='blue')

# Plotar previs√µes do modelo
plt.plot(forecast_test['ds'], forecast_test['yhat'], label='Previs√£o Prophet', color='red')

plt.title("Compara√ß√£o: Previs√µes vs. Valores Reais")
plt.xlabel("Data")
plt.ylabel("Consumo Total de Energia")
plt.legend()
plt.show()

# Plotar os componentes da previs√£o (tend√™ncia e sazonalidade)
modelo.plot_components(forecast)
plt.show()

# Criar um DataFrame comparativo entre valores reais e previstos
df_comparacao = pd.DataFrame({
    "timestamp": test["ds"].values,
    "valor_real": test["y"].values,
    "previsao_prophet": forecast_test["yhat"].values,
    "erro_absoluto": np.abs(test["y"].values - forecast_test["yhat"].values)
})

# Exibir as primeiras linhas do DataFrame
df_comparacao.head()

# Fun√ß√£o para salvar previs√µes no banco de dados
def salvar_previsao_no_banco(forecast_test):
    """Insere as previs√µes do modelo Prophet na tabela 'previsao_consumo'."""
    conn = get_db_connection()
    
    if not conn:
        print("‚ùå N√£o foi poss√≠vel conectar ao banco de dados para salvar as previs√µes.")
        return
    
    try:
        with conn.cursor() as cursor:
            # Query para inserir as previs√µes na tabela previsao_consumo
            query = """
                INSERT INTO previsao_consumo (timestamp, consumo)
                VALUES (%s, %s)
            """
            
            # Itera sobre as previs√µes e insere no banco
            for _, row in forecast_test.iterrows():
                timestamp = row['ds']
                previsao = row['yhat']
                cursor.execute(query, (timestamp, previsao))
            
            # Commit para salvar as altera√ß√µes no banco de dados
            conn.commit()
            print("‚úÖ Previs√µes salvas com sucesso no banco de dados!")
    
    except pymysql.MySQLError as e:
        print(f"‚ùå Erro ao salvar as previs√µes no banco de dados: {e}")
    
    finally:
        conn.close()

# Fun√ß√£o para treinar, testar e prever as medi√ß√µes futuras
def treinar_e_prever():
    # Dividir os dados aleatoriamente em 80% treino e 20% teste
    train, test = train_test_split(df, test_size=0.2)

    # Ordenar os dados pelo timestamp dentro de cada conjunto para manter a coer√™ncia temporal
    train = train.sort_values(by="ds")
    test = test.sort_values(by="ds")

    # Criar e treinar o modelo Prophet
    modelo = Prophet()
    modelo.fit(train)

    # Criar um dataframe com datas futuras para o per√≠odo de teste
    future = modelo.make_future_dataframe(periods=len(test), freq='10min')

    # Fazer a previs√£o
    forecast = modelo.predict(future)

    # Selecionar apenas as previs√µes correspondentes ao per√≠odo de teste
    forecast_test = forecast.iloc[-len(test):]

    # Exibir as primeiras previs√µes
    print(forecast_test[['ds', 'yhat']].head())

    # Calcular as m√©tricas de avalia√ß√£o
    test['y'] = test['y'].fillna(0)
    nan_count = test['y'].isna().sum()
    print(f"NaN na coluna 'y': {nan_count}")

    mae = mean_absolute_error(test['y'], forecast_test['yhat'])
    mse = mean_squared_error(test['y'], forecast_test['yhat'])
    rmse = np.sqrt(mse)

    print(f"MAE: {mae:.2f}")
    print(f"MSE: {mse:.2f}")
    print(f"RMSE: {rmse:.2f}")

    plt.figure(figsize=(12, 6))
    # Plotar valores reais do conjunto de teste
    plt.plot(test['ds'], test['y'], label='Valores Reais', color='blue')
    # Plotar previs√µes do modelo
    plt.plot(forecast_test['ds'], forecast_test['yhat'], label='Previs√£o Prophet', color='red')
    plt.title("Compara√ß√£o: Previs√µes vs. Valores Reais")
    plt.xlabel("Data")
    plt.ylabel("Consumo Total de Energia")
    plt.legend()
    plt.show()

    # Plotar os componentes da previs√£o (tend√™ncia e sazonalidade)
    modelo.plot_components(forecast)
    plt.show()

    # Salvar as previs√µes no banco
    salvar_previsao_no_banco(forecast_test)

    # Agora prever as pr√≥ximas medi√ß√µes para o pr√≥ximo dia (por exemplo, usando 24 horas a mais)
    future_next_day = modelo.make_future_dataframe(periods=24*4, freq='10min')  # 24h * 4 (a cada 15 minutos)
    
    # Prever as futuras medi√ß√µes
    forecast_next_day = modelo.predict(future_next_day)

    # Exibir as previs√µes do pr√≥ximo dia
    forecast_next_day[['ds', 'yhat']].tail()

    # Salvar as previs√µes futuras no banco
    salvar_previsao_no_banco(forecast_next_day.tail(24*4))  # Ajustar o n√∫mero de previs√µes se necess√°rio

# Chame a fun√ß√£o para treinar, testar e prever as medi√ß√µes futuras
treinar_e_prever()
